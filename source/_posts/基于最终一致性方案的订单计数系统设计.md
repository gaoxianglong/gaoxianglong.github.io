---
title: 基于最终一致性方案的订单计数系统设计
date: 2025-04-15 19:20:35
tags: 系统架构
---
## 背景
在实际的开发过程中，计数统计是一项非常常见的功能性需求。无论是在内容类平台，还是社交类应用中，都广泛存在着计数类场景。例如，在博客系统中，我们需要统计不同分类下的文章数量；在微博系统中，则可能涉及到统计粉丝数量、关注数、微博数、评论数等多维度数据。
<br>

**数据的变更频率和C端访问压力，往往决定了不同的技术选型和方案**。为了高效、稳定地支撑业务所需的计数功能，我们通常有3种主流方案可供选择：
- 基于关系型数据库（RDBMS）的 COUNT 查询；
- 基于 Elasticsearch 倒排索引的聚合统计；
- 基于最终一致性的计数统计方案。
<br>

本文我们将探讨下交易系统中订单计数统计应该怎么去设计和落地。我们的实际单量在百万级+/天，C端需要对客展示 '待支付' 和 '待出行' 等2种状态的的用户单量数，如果是直接使用COUNT+GROUPBY语句去生产交易库统计查询会对DB产生不小的压力，**尽管在RDBMS中单片千万+ 数量级的统计查询如果能够命中联合索引，那么也能够做到毫秒级响应，但为了避免并发量过大导致系统产生雪崩**，以及同时考虑到这类查询计数功能并非是主流程的必要功能，因此我们决定采用基于最终一致性的订单计数统计方案。

## 基于最终一致性的订单计数统计方案
如图1所示，当交易系统成功流转订单状态（待支付、待出行）后，便会异步通知订单计数服务。计数服务消费到对应的变更事件后，自行计算并更新缓存中的订单数量即可。当用户发起订单数量查询时，计数服务直接从缓存中获取并返回，不再直接将请求打到交易库中进行统计查询，从而大幅度降低数据库的负载压力。
![图1-订单计数设计方案](https://static001.geekbang.org/infoq/16/164841b9bffcfb1c01edf65ebae9abc8.png)

大家思考3个问题，首先是存量数据如何预热？其次如何平衡数据一致性的问题？最后是如何解决缓存穿透的问题？

## 数据预热时的一致性问题&穿透问题
正常情况下，我们很容易想到，当C端发起查询请求时，如果计数服务从缓存中取不到数据，必然会去交易库中COUNT一把再进行缓存预热。**但在分布式环境下，各个执行环节都有可能产生故障从而影响数据一致性**。这里假设订单状态发生变更，交易系统通知计数服务时产生网络抖动，而C端正常请求计数服务拉取订单数量时，由于缓存数据为空，如果计数服务直接从交易库COUNT并SET CACHE，那么后续网络恢复后，由于计数服务存在延迟消费，必然会导致正确数据被篡改，当用户发起二次查询时必然会产生脏读，如图2所示。
![图2-数据一致性问题](https://static001.geekbang.org/infoq/94/94c24f48798b8209697e0dc80a4594f7.png)

如图3所示，假设缓存miss的时候，计数服务直接COUNT交易库并返回给C端用户，而不进行数据预热，等产生变更事件的时候再执行CACHE SET是不是就能解决图2的数据一致性的问题？
![图3-缓存穿透问题](https://static001.geekbang.org/infoq/6c/6c75e01bcaa710db728c05a9e612edf1.png)

首先我们要搞清楚的是，这并不是一个强一致性的设计，**我们不可能100%保证缓存中的订单数量和交易库中的真实订单数量在任何情况下都完全一致，我们只能确保数据在大部分情况下是一致的，业务上务必要具备短期数据不一致的容错性**。

## 解决方案
- **基于事件id进行幂等去重消费；**
- **写时更新 + 异步预热 + 最终一致性校准。**

计数服务总共接收2个事件，分别是： '变更事件' 和 '预热事件'。变更事件由交易系统发起，而预热事件则由计数服务发起，只不过这里并不是同步动作，而是异步预热，也就是说，当C端发起查询请求时，如果cache miss，那么计数服务会发送预热事件给MQ，进行异步数据预热，cache miss时对客暂时返回0。这样当预热完成后，C端再次发起查询请求时，便能拿到订单数量，业务上一定要允许这样的容错设计，只是要确保数据不一致性的窗口期要足够短，尽可能降低对客体验不友好的情况。**交易系统将变更事件通知给计数服务时，计数服务要先判断缓存是否为空，如果为空则需要将变更事件变更为预热事件执行**。
<br>

缓存的数据结构采用HASH结构，如下所示：
```Java
member-id ->
            order-type  -> order count
            update-time -> timestamp
```

如图4所示，计数服务在执行预热事件时，如果恰好存在并发，也就是交易系统刚好流转完订单状态，这个时候当交易系统下发变更事件时，会导致正确预热后的数据被错误篡改，但不重要，当C端进行订单数量查询时，**如果check到数据过期，则执行校准动作（数据常驻内存，全量更新）**，我们真正要确保的是数据看上去大致是对的即可。因为在大部分正常情况下，用户的操作均是线性的，几乎都能够返回正确的订单数量，只有在业务高峰期，以及网络抖动时才会导致数据存在短期不一致。
![图4-写时更新+异步预热+最终一致性校准](https://static001.geekbang.org/infoq/8b/8b193f88932c198a815a60e83673cf7b.png)


总的来说，在 分布式系统架构设计中，方案选型永远无法做到“既要… 又要… 还要…”，我们的追求的是“可用优先”+“高频近似正确”的原则。